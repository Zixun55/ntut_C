#include<stdio.h>
int swap(int *a, int *b) {
	int tmp;
	tmp = *a;
	*a = *b;
	*b= tmp;
}
int permutation(int* str,int begin,int end,int e[][200],int ans[]){ 
    int i;
    if(begin == end){ 
        int node = 1,next = str[1],store=0;
        for( i = 0; i<end; i++){
            store+=e[node-1][next-1];
            node = next;
            next = str[i+2];
        }	
        if (store < ans[0]) ans[0] = store;
    }  
    else{  
        for( i = begin; i <= end; i++){
            swap(&str[i], &str[begin]);
            permutation(str, begin + 1, end, e, ans);  
            swap(&str[i], &str[begin]);
        }  
    }  
}
int main(){
    int n,e[200][200],ans[1]={5000},tmp[200];//城市數，各城市到其他城市的距離，答案，城市名
    char a;
    int b;
    scanf("%d",&n);
    for (int i=0;i<=n;i++){
        if (i == 0) scanf("%d%c",&b,&a);
        else scanf("%d%c",&tmp[i-1],&a);
    }
    
    for (int i=0;i<n;i++){
        for (int j=0;j<=n;j++){
            if(j == 0) scanf("%d%c",&b,&a);
            else scanf("%d%c",&e[i][j-1],&a);
        }
    }
    permutation(tmp, 1, n-1, e, ans);
    printf("%d",ans[0]);
    return 0;
}

// 賴先生騎腳踏車挑戰一日N塔，N<10。
// 每一個塔位在編號 1, 2, 3, ...,N 城市中。
// 每兩個城市都有一段距離的公路相連。
// 先輸入一個正整數N，
// 再輸入各個城市距離的對照表(第一行和第一列為城市之間對應關係，其他數字為兩個城市之間的距離)，
// 請輸出從第 1 個城市出發，騎過每一個城市的最短距離為多少?

// 範例一：
// ---------------------------------------------------
// input:
// 5
// 0 1 2 3 4 5
// 1 0 4 2 3 6
// 2 4 0 3 1 4
// 3 2 3 0 2 5
// 4 3 1 2 0 3
// 5 6 4 5 3 0
// ---------------------------------------------------
// output:
// 9
// ---------------------------------------------------
// 說明：
// 五個城市兩兩城市之間公路的距離：
// 城市 1 和城市 2 的距離是 4
// 城市 1 和城市 3 的距離是 2
// 城市 1 和城市 4 的距離是 3
// 城市 1 和城市 5 的距離是 6
// 城市 3 和城市 4 的距離是 2
// 城市 5 和城市 4 的距離是 3
// .......以此類推
// 最短路徑：1 -> 3 -> 2 -> 4 -> 5
// 最短距離：2 + 3 + 1 + 3 = 9
// ---------------------------------------------------

// 範例二：
// ---------------------------------------------------
// input:
// 6
// 0 1 2 3 4 5 6
// 1 0 4 2 3 6 3
// 2 4 0 3 1 4 5
// 3 2 3 0 2 5 3
// 4 3 1 2 0 3 3
// 5 6 4 5 3 0 2
// 6 3 5 3 3 2 0
// ---------------------------------------------------
// output:
// 11

